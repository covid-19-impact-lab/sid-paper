\subsection{Matching Individuals}
\label{sec:matching}

The empirical data described above only allows to estimate the number of contacts each
person has. In order to simulate transmissions of Covid-19, the numbers of contacts has
to be translated into actual meetings between people. This is achieved by matching
algorithms:

As described in section \ref{sec:number_of_contacts}, some contact types are recurrent
(i.e. the same people meet regularly), others are non-recurrent (i.e. it would only be
by accident that two people meet twice). The matching process is different for recurrent
and non recurrent contact models.

Recurrent contacts are described by two components: 1) A variable in the background
characteristics. An example would be a school class identifier which could come from
actual data or be drawn randomly to achieve representative class sizes. 2) A
deterministic or random function that takes the value 0 (non-participating) and 1
(participating) and can depend on the weekday, date and health state. This can be used
to model vacations, weekends or symptomatic people who stay home (see section
\ref{sec:endogenous_contact_reductions} for details).

The matching process for recurrent contacts is then extremely simple: On each simulated
day, every person who does not stay home meets all other group members who do not stay
home. The assumption that all group members have contacts with all other group members
is not fully realistic, but seems like a good approximation to reality, especially in
light of the suspected role of aerosol transmission for Covid-19 \citep{Morawska2020,
Anderson2020}.

The matching in non-recurrent contact models is more difficult and implemented in a two
stage sampling procedure to allow for assortative matching. Currently most contact
models are assortative with respect to age (it is more likely to meet people from the
same age group) and county (it is more likely to meet people from the same county) but
in principle any set of discrete variables can be used. This set of variables that
influence matching probabilities introduce a discrete partition of the population into
groups. The first stage of the two stage sampling process samples on the group level.
The second stage on the individual level.

Below, we first show pseudo code for the non-recurrent matching algorithm and then
describe how the algorithm works in words.

\begin{listing}
    \label{code:matching}
    \begin{minted}{python}
        while are_unmatched_contacts_left:

            contact_type, i = draw_contact_type_and_individual()

            for _ in remaining_contacts[i, contact_type]:

                group_j = draw_group_of_other_person()
                j = draw_other_person_from_that_group(group_j)

                if infection_takes_places(i, j):
                    # Update health statuses.

                remaining_contacts[i, contact_type] -= 1
                remaining_contacts[j, contact_type] -= 1
    \end{minted}
    \caption{Pseudo-code for the matching algorithm of non-recurrent contacts.}
\end{listing}

We first randomly draw a contact type and individual. For each contact of the drawn
contact type that person has, we first draw the group of the other person (first stage).
Next, we calculate the probability to be drawn for each member of the group, based on
the number of remaining contacts. I.e. people who have more remaining contacts are drawn
with a higher probability. This has to be re-calculated each time because with each
matched contact, the number of remaining contacts changes. We then draw the other
individual, determine whether an infection takes place and if so update the health
states of the newly infected person. Finally, we reduce the number of remaining contacts
of the two matched individuals by one.

The recalculation of matching probabilities in the second stage is computationally
intensive because it requires summing up all remaining contacts in that group. Using a
two stage sampling process where the first stage probabilities remain constant over time
makes the matching computationally much more tractable because the number of
computations increases quadratically in the second stage group size.
